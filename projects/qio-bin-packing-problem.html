---
layout: project
title: Bin Packing Problem (BPP) — Quantum-Inspired Optimization
description: MILP/QUBO formulations and classical vs quantum-inspired solvers for bin packing.
---

<!-- Project Hero -->
<section class="project-hero">
  <div class="project-hero-content">
    <div class="project-breadcrumb">
      <a href="{{ '/' | relative_url }}">Home</a>
      <span>→</span>
      <a href="{{ '/' | relative_url }}#projects">Projects</a>
      <span>→</span>
      <a href="{{ '/projects/quantum-inspired-optimization.html' | relative_url }}">Quantum-Inspired Optimization</a>
      <span>→</span>
      <span>Bin Packing Problem</span>
    </div>

    <h1>Bin Packing Problem (BPP)</h1>
    <p class="project-hero-subtitle">
      Packing items into the minimum number of capacity-constrained bins using MILP/QUBO formulations.
    </p>

    <div class="project-tags">
      <span class="project-tag">BPP</span>
      <span class="project-tag">MILP</span>
      <span class="project-tag">QUBO</span>
      <span class="project-tag">Pyomo</span>
      <span class="project-tag">QAOA</span>
      <span class="project-tag">Quantum Annealing</span>
      <span class="project-tag">D-Wave</span>
    </div>

    <div class="project-links">
      <a href="https://github.com/harishaseebat92/Quantum_Inspired_Optimization" target="_blank" class="project-link-btn primary">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/>
          <path d="M9 18c-4.51 2-5-2-7-2"/>
        </svg>
        View Repository
      </a>
      <a href="{{ '/projects/quantum-inspired-optimization.html' | relative_url }}" class="project-link-btn secondary">
        ← Back to Quantum-Inspired Optimization
      </a>
    </div>
  </div>
</section>

<div class="project-content-wrapper">
  <article class="project-content">

    <section id="overview" class="project-section">
      <h2>Overview</h2>
      <p>
        The Bin Packing Problem (BPP) is a classic NP-hard optimization problem.
        We are given a set of items, each with a weight, and identical bins with a fixed maximum capacity.
        The objective is to pack all items using the <em>minimum</em> number of bins, while never exceeding the
        capacity of any bin.
      </p>

      <p>
        In formal terms: given $n$ items with weights $w_1, w_2, \ldots, w_n$ and bin capacity $C$, we want
        a feasible assignment of items to bins that minimizes how many bins are used.
      </p>
    </section>

    <section id="formulation" class="project-section">
      <h2>1. Mathematical formulation</h2>

      <h3>1.1 Integer Linear Programming (ILP) formulation</h3>
      <p>
        Let $m$ be an upper bound on the number of bins (commonly $m=n$, since in the worst case each item can go into its own bin).
      </p>

      <h4>Decision variables</h4>
      <ul>
        <li>
          <strong>Item assignment:</strong>
          $x_{ij} \in \{0,1\}$ where
          $$
          x_{ij} =
          \begin{cases}
          1 & \text{if item } i \text{ is placed in bin } j,\\
          0 & \text{otherwise.}
          \end{cases}
          $$
        </li>
        <li>
          <strong>Bin usage indicator:</strong>
          $y_j \in \{0,1\}$ where
          $$
          y_j =
          \begin{cases}
          1 & \text{if bin } j \text{ is used,}\\
          0 & \text{otherwise.}
          \end{cases}
          $$
        </li>
      </ul>

      <h4>Objective function</h4>
      <p>
        Minimize the number of used bins:
      </p>
      $$
      \min \sum_{j=1}^{m} y_j
      $$

      <h4>Constraints</h4>
      <ol>
        <li>
          <strong>Each item must be assigned to exactly one bin:</strong>
          $$
          \sum_{j=1}^{m} x_{ij} = 1, \quad \forall i \in \{1,2,\ldots,n\}.
          $$
        </li>
        <li>
          <strong>Capacity constraint for each bin:</strong>
          $$
          \sum_{i=1}^{n} w_i x_{ij} \le C y_j, \quad \forall j \in \{1,2,\ldots,m\}.
          $$
          <div style="margin-top: 0.6em; color: rgba(0,0,0,0.75);">
            The variable $y_j$ acts as an “on/off” switch: if $y_j=0$, no item can be assigned to bin $j$.
            If $y_j=1$, the bin can be used but must respect the capacity $C$.
          </div>
        </li>
        <li>
          <strong>Binary constraints:</strong>
          $$
          x_{ij} \in \{0,1\} \; \forall i,j, \qquad y_j \in \{0,1\} \; \forall j.
          $$
        </li>
      </ol>

      <h4>Interpretation (what each term means)</h4>
      <ul>
        <li><strong>$\sum_{j=1}^{m} y_j$</strong>: total number of bins used (and what we minimize).</li>
        <li><strong>$\sum_{j=1}^{m} x_{ij} = 1$</strong>: ensures every item is placed exactly once.</li>
        <li><strong>$\sum_{i=1}^{n} w_i x_{ij} \le C y_j$</strong>: enforces capacity and prevents packing into unused bins.</li>
      </ul>
    </section>

    <section id="how-we-solve" class="project-section">
      <h2>2. How we solve it</h2>
      <p>
        Once we have the ILP, we can solve or approximate BPP in multiple ways depending on problem size.
      </p>

      <h3>2.1 Classical optimization</h3>
      <ul>
        <li>
          <strong>Exact ILP/MILP (Pyomo + solver):</strong> works well for small-to-medium instances and provides strong baselines.
        </li>
        <li>
          <strong>Heuristics (e.g., First-Fit Decreasing):</strong> fast baseline for larger instances.
        </li>
      </ul>

      <h3>2.2 Quantum-inspired optimization</h3>
      <p>
        To use quantum-inspired solvers, we typically convert constrained formulations into QUBO by embedding
        constraints via penalty terms.
      </p>
      <ul>
        <li><strong>QUBO formulation:</strong> a quadratic objective over binary variables (unconstrained).</li>
        <li><strong>Quantum annealing:</strong> solve the QUBO with annealers (e.g., D-Wave) or annealing-inspired classical solvers.</li>
        <li><strong>QAOA:</strong> build a parameterized circuit from the problem Hamiltonian and optimize angles with a classical optimizer.</li>
      </ul>
    </section>

    <section id="example" class="project-section">
      <h2>3. Small example instance</h2>
      <p>
        Consider item weights
        $$
        	exttt{weights} = [3,2,3,4]
        $$
        and bin capacity
        $$
        C = \max(\texttt{weights}) + 2 = 6.
        $$
        The goal is to minimize the number of bins used.
      </p>

      <p>
        If we choose an upper bound $m=2$ bins (labeled $j\in\{0,1\}$) and index items $i\in\{0,1,2,3\}$, then:
      </p>

      <h3>Objective</h3>
      $$
      \min (y_0 + y_1)
      $$

      <h3>Constraints</h3>
      <p><strong>Item assignment:</strong></p>
      $$
      x_{i0} + x_{i1} = 1 \quad \forall i\in\{0,1,2,3\}.
      $$

      <p><strong>Bin capacities:</strong></p>
      $$
      3x_{0j} + 2x_{1j} + 3x_{2j} + 4x_{3j} \le 6y_j \quad \forall j\in\{0,1\}.
      $$

      <p>
        (Optionally) you can add symmetry-breaking / pre-assignment constraints. For example, forcing item $0$ into bin $0$:
      </p>
      $$
      x_{00} = 1.
      $$

      <h3>3.1 Brute-force approach (for small instances)</h3>
      <p>
        For small $n$ (few items) we can also solve BPP by brute force by enumerating all feasible assignments
        $x_{ij}$ and picking the first solution that fits within the smallest possible number of bins.
        This is not scalable, but it’s a great sanity-check for the ILP/QUBO formulations.
      </p>

      <h4>Step 1: estimate the minimum number of bins</h4>
      <p>
        Let $W = \sum_{i=1}^{n} w_i$ be the total weight. A simple lower bound on the number of bins is:
      </p>
      $$
      Y_{\min} = \left\lceil \frac{W}{C} \right\rceil.
      $$
      <p>
        In practice, we can start from this bound (or other bounds) and increment the bin count $Y$ until a feasible
        assignment is found.
      </p>

      <h4>Step 2: enumerate valid assignments</h4>
      <p>
        Enumerate all binary matrices $x_{ij}$ (items $i$ to bins $j$) and keep only those that satisfy the “one bin per item” constraint:
      </p>
      $$
      \sum_{j=1}^{Y} x_{ij} = 1, \quad \forall i.
      $$

      <h4>Step 3: check capacity constraints</h4>
      <p>
        For each candidate assignment, check capacity feasibility for each bin:
      </p>
      $$
      \sum_{i=1}^{n} w_i x_{ij} \le C, \quad \forall j \in \{1,\ldots,Y\}.
      $$

      <h4>Step 4: return the first feasible solution for the smallest $Y$</h4>
      <p>
        If no assignment works for the current $Y$, increment $Y$ and repeat.
        The first feasible $Y$ is the brute-force optimum bin count.
      </p>

      <h4>Example output assignment</h4>
      <p>
        For $\texttt{weights}=[3,2,3,4]$ and $C=6$, one feasible solution uses $Y=2$ bins and can be written as:
      </p>
      $$
      X =
      \begin{bmatrix}
      x_{11} & x_{12} \\
      x_{21} & x_{22} \\
      x_{31} & x_{32} \\
      x_{41} & x_{42}
      \end{bmatrix}
      =
      \begin{bmatrix}
      0 & 1 \\
      1 & 0 \\
      0 & 1 \\
      1 & 0
      \end{bmatrix}
      $$
      <p>
        Interpretation: item 1 goes to bin 2, item 2 to bin 1, item 3 to bin 2, and item 4 to bin 1.
        Bin loads are $2+4=6$ and $3+3=6$, so both bins respect the capacity.
      </p>
    </section>

    <section id="notes" class="project-section">
      <h2>Notes</h2>
      <p>
        This page is part of my <a href="{{ '/projects/quantum-inspired-optimization.html' | relative_url }}">Quantum-Inspired Optimization</a>
        coursework repository.
      </p>
    </section>

  </article>

  <aside class="project-sidebar">
    <nav class="project-toc">
      <h4>Contents</h4>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#formulation">1. Mathematical formulation</a></li>
        <li><a href="#how-we-solve">2. How we solve it</a></li>
        <li><a href="#example">3. Small example instance</a></li>
        <li><a href="#notes">Notes</a></li>
      </ul>
    </nav>
  </aside>
</div>
