---
layout: project
title: Bin Packing Problem (BPP) — Quantum-Inspired Optimization
description: MILP/QUBO formulations and classical vs quantum-inspired solvers for bin packing.
---

<!-- Project Hero -->
<section class="project-hero">
  <div class="project-hero-content">
    <div class="project-breadcrumb">
      <a href="{{ '/' | relative_url }}">Home</a>
      <span>→</span>
      <a href="{{ '/' | relative_url }}#projects">Projects</a>
      <span>→</span>
      <a href="{{ '/projects/quantum-inspired-optimization.html' | relative_url }}">Quantum-Inspired Optimization</a>
      <span>→</span>
      <span>Bin Packing Problem</span>
    </div>

    <h1>Bin Packing Problem (BPP)</h1>
    <p class="project-hero-subtitle">
      Packing items into the minimum number of capacity-constrained bins using MILP/QUBO formulations.
    </p>

    <div class="project-tags">
      <span class="project-tag">BPP</span>
      <span class="project-tag">MILP</span>
      <span class="project-tag">QUBO</span>
      <span class="project-tag">Pyomo</span>
      <span class="project-tag">QAOA</span>
      <span class="project-tag">Quantum Annealing</span>
      <span class="project-tag">D-Wave</span>
    </div>

    <div class="project-links">
      <a href="https://github.com/harishaseebat92/Quantum_Inspired_Optimization" target="_blank" class="project-link-btn primary">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/>
          <path d="M9 18c-4.51 2-5-2-7-2"/>
        </svg>
        View Repository
      </a>
      <a href="{{ '/projects/quantum-inspired-optimization.html' | relative_url }}" class="project-link-btn secondary">
        ← Back to Quantum-Inspired Optimization
      </a>
    </div>
  </div>
</section>

<div class="project-content-wrapper">
  <article class="project-content">

    <section id="overview" class="project-section">
      <h2>Overview</h2>
      <p>
        The Bin Packing Problem (BPP) is a classic NP-hard optimization problem.
        We are given a set of items, each with a weight, and identical bins with a fixed maximum capacity.
        The objective is to pack all items using the <em>minimum</em> number of bins, while never exceeding the
        capacity of any bin.
      </p>

      <p>
        In formal terms: given $n$ items with weights $w_1, w_2, \ldots, w_n$ and bin capacity $C$, we want
        a feasible assignment of items to bins that minimizes how many bins are used.
      </p>

      <h3 style="margin-top: 1.25em;">Quantum optimization workflow (high-level)</h3>
      <p>
        Below is the workflow used in the repository to go from a classical formulation to a quantum (or quantum-inspired)
        optimizer.
      </p>

      <!-- Web-native flowchart (TikZ-like) -->
      <div style="max-width: 520px; margin: 16px auto 0;">
        <div style="display:flex; flex-direction:column; gap: 12px; align-items:stretch;">
          <div style="position:relative;">
            <div style="background: rgba(0,102,204,0.08); border: 2px solid rgba(0,102,204,0.35); border-radius: 12px; padding: 12px 14px; text-align:center; font-weight: 700;">
              Bin Packing Problem
            </div>
            <div style="text-align:left; font-size: 12px; color: rgba(0,0,0,0.7); margin-top: 6px;">Formulate</div>
          </div>

          <div style="text-align:center; color: rgba(0,102,204,0.9); font-weight: 700;">↓</div>

          <div>
            <div style="background: rgba(0,102,204,0.08); border: 2px solid rgba(0,102,204,0.35); border-radius: 12px; padding: 12px 14px; text-align:center; font-weight: 700;">
              ILP Model <span style="font-weight: 500;">(Docplex)</span>
            </div>
            <div style="text-align:left; font-size: 12px; color: rgba(0,0,0,0.7); margin-top: 6px;">Convert (<code>from_docplex_mp</code>)</div>
          </div>

          <div style="text-align:center; color: rgba(0,102,204,0.9); font-weight: 700;">↓</div>

          <div>
            <div style="background: rgba(0,102,204,0.08); border: 2px solid rgba(0,102,204,0.35); border-radius: 12px; padding: 12px 14px; text-align:center; font-weight: 700;">
              QUBO Model <span style="font-weight: 500;">(QuadraticProgram)</span>
            </div>
            <div style="text-align:left; font-size: 12px; color: rgba(0,0,0,0.7); margin-top: 6px;">Map (<code>to_ising</code>)</div>
          </div>

          <div style="text-align:center; color: rgba(0,102,204,0.9); font-weight: 700;">↓</div>

          <div>
            <div style="background: rgba(0,102,204,0.08); border: 2px solid rgba(0,102,204,0.35); border-radius: 12px; padding: 12px 14px; text-align:center; font-weight: 700;">
              Ising Model
            </div>
            <div style="text-align:left; font-size: 12px; color: rgba(0,0,0,0.7); margin-top: 6px;">Solve (<code>QAOA</code>/<code>VQE</code>)</div>
          </div>

          <div style="text-align:center; color: rgba(0,102,204,0.9); font-weight: 700;">↓</div>

          <div>
            <div style="background: rgba(0,102,204,0.08); border: 2px solid rgba(0,102,204,0.35); border-radius: 12px; padding: 12px 14px; text-align:center; font-weight: 700;">
              VQA Solver <span style="font-weight: 500;">(Qiskit)</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="formulation" class="project-section">
      <h2>1. Mathematical formulation</h2>

      <h3>1.1 Integer Linear Programming (ILP) formulation</h3>
      <p>
        Let $m$ be an upper bound on the number of bins (commonly $m=n$, since in the worst case each item can go into its own bin).
      </p>

      <h4>Decision variables</h4>
      <ul>
        <li>
          <strong>Item assignment:</strong>
          $x_{ij} \in \{0,1\}$ where
          $$
          x_{ij} =
          \begin{cases}
          1 & \text{if item } i \text{ is placed in bin } j,\\
          0 & \text{otherwise.}
          \end{cases}
          $$
        </li>
        <li>
          <strong>Bin usage indicator:</strong>
          $y_j \in \{0,1\}$ where
          $$
          y_j =
          \begin{cases}
          1 & \text{if bin } j \text{ is used,}\\
          0 & \text{otherwise.}
          \end{cases}
          $$
        </li>
      </ul>

      <h4>Objective function</h4>
      <p>
        Minimize the number of used bins:
      </p>
      $$
      \min \sum_{j=1}^{m} y_j
      $$

      <h4>Constraints</h4>
      <ol>
        <li>
          <strong>Each item must be assigned to exactly one bin:</strong>
          $$
          \sum_{j=1}^{m} x_{ij} = 1, \quad \forall i \in \{1,2,\ldots,n\}.
          $$
        </li>
        <li>
          <strong>Capacity constraint for each bin:</strong>
          $$
          \sum_{i=1}^{n} w_i x_{ij} \le C y_j, \quad \forall j \in \{1,2,\ldots,m\}.
          $$
          <div style="margin-top: 0.6em; color: rgba(0,0,0,0.75);">
            The variable $y_j$ acts as an “on/off” switch: if $y_j=0$, no item can be assigned to bin $j$.
            If $y_j=1$, the bin can be used but must respect the capacity $C$.
          </div>
        </li>
        <li>
          <strong>Binary constraints:</strong>
          $$
          x_{ij} \in \{0,1\} \; \forall i,j, \qquad y_j \in \{0,1\} \; \forall j.
          $$
        </li>
      </ol>

      <h4>Interpretation (what each term means)</h4>
      <ul>
        <li><strong>$\sum_{j=1}^{m} y_j$</strong>: total number of bins used (and what we minimize).</li>
        <li><strong>$\sum_{j=1}^{m} x_{ij} = 1$</strong>: ensures every item is placed exactly once.</li>
        <li><strong>$\sum_{i=1}^{n} w_i x_{ij} \le C y_j$</strong>: enforces capacity and prevents packing into unused bins.</li>
      </ul>
    </section>

    <section id="how-we-solve" class="project-section">
      <h2>2. How we solve it</h2>
      <p>
        Once we have the ILP, we can solve or approximate BPP in multiple ways depending on problem size.
      </p>

      <h3>2.1 Classical optimization</h3>
      <ul>
        <li>
          <strong>Exact ILP/MILP (Pyomo + solver):</strong> works well for small-to-medium instances and provides strong baselines.
        </li>
        <li>
          <strong>Heuristics (e.g., First-Fit Decreasing):</strong> fast baseline for larger instances.
        </li>
      </ul>

      <h3>2.2 Quantum-inspired optimization</h3>
      <p>
        To use quantum-inspired solvers, we typically convert constrained formulations into QUBO by embedding
        constraints via penalty terms.
      </p>
      <ul>
        <li><strong>QUBO formulation:</strong> a quadratic objective over binary variables (unconstrained).</li>
        <li><strong>Quantum annealing:</strong> solve the QUBO with annealers (e.g., D-Wave) or annealing-inspired classical solvers.</li>
        <li><strong>QAOA:</strong> build a parameterized circuit from the problem Hamiltonian and optimize angles with a classical optimizer.</li>
      </ul>
    </section>

    <section id="example" class="project-section">
      <h2>3. Small example instance</h2>
      <p>
        Consider item weights
        $$
        	exttt{weights} = [3,2,3,4]
        $$
        and bin capacity
        $$
        C = \max(\texttt{weights}) + 2 = 6.
        $$
        The goal is to minimize the number of bins used.
      </p>

      <p>
        If we choose an upper bound $m=2$ bins (labeled $j\in\{0,1\}$) and index items $i\in\{0,1,2,3\}$, then:
      </p>

      <h3>Objective</h3>
      $$
      \min (y_0 + y_1)
      $$

      <h3>Constraints</h3>
      <p><strong>Item assignment:</strong></p>
      $$
      x_{i0} + x_{i1} = 1 \quad \forall i\in\{0,1,2,3\}.
      $$

      <p><strong>Bin capacities:</strong></p>
      $$
      3x_{0j} + 2x_{1j} + 3x_{2j} + 4x_{3j} \le 6y_j \quad \forall j\in\{0,1\}.
      $$

      <p>
        (Optionally) you can add symmetry-breaking / pre-assignment constraints. For example, forcing item $0$ into bin $0$:
      </p>
      $$
      x_{00} = 1.
      $$

      <h3>3.1 Brute-force approach (for small instances)</h3>
      <p>
        For small $n$ (few items) we can also solve BPP by brute force by enumerating all feasible assignments
        $x_{ij}$ and picking the first solution that fits within the smallest possible number of bins.
        This is not scalable, but it’s a great sanity-check for the ILP/QUBO formulations.
      </p>

      <h4>Step 1: estimate the minimum number of bins</h4>
      <p>
        Let $W = \sum_{i=1}^{n} w_i$ be the total weight. A simple lower bound on the number of bins is:
      </p>
      $$
      Y_{\min} = \left\lceil \frac{W}{C} \right\rceil.
      $$
      <p>
        In practice, we can start from this bound (or other bounds) and increment the bin count $Y$ until a feasible
        assignment is found.
      </p>

      <h4>Step 2: enumerate valid assignments</h4>
      <p>
        Enumerate all binary matrices $x_{ij}$ (items $i$ to bins $j$) and keep only those that satisfy the “one bin per item” constraint:
      </p>
      $$
      \sum_{j=1}^{Y} x_{ij} = 1, \quad \forall i.
      $$

      <h4>Step 3: check capacity constraints</h4>
      <p>
        For each candidate assignment, check capacity feasibility for each bin:
      </p>
      $$
      \sum_{i=1}^{n} w_i x_{ij} \le C, \quad \forall j \in \{1,\ldots,Y\}.
      $$

      <h4>Step 4: return the first feasible solution for the smallest $Y$</h4>
      <p>
        If no assignment works for the current $Y$, increment $Y$ and repeat.
        The first feasible $Y$ is the brute-force optimum bin count.
      </p>

      <h4>Example output assignment</h4>
      <p>
        For $\texttt{weights}=[3,2,3,4]$ and $C=6$, one feasible solution uses $Y=2$ bins and can be written as:
      </p>
      $$
      X =
      \begin{bmatrix}
      x_{11} & x_{12} \\
      x_{21} & x_{22} \\
      x_{31} & x_{32} \\
      x_{41} & x_{42}
      \end{bmatrix}
      =
      \begin{bmatrix}
      0 & 1 \\
      1 & 0 \\
      0 & 1 \\
      1 & 0
      \end{bmatrix}
      $$
      <p>
        Interpretation: item 1 goes to bin 2, item 2 to bin 1, item 3 to bin 2, and item 4 to bin 1.
        Bin loads are $2+4=6$ and $3+3=6$, so both bins respect the capacity.
      </p>
    </section>

    <section id="ilp-to-qubo" class="project-section">
      <h2>4. ILP to QUBO Conversion</h2>
      <p>
        To solve BPP using quantum or quantum-inspired methods, the constrained ILP is typically transformed into a
        <strong>Quadratic Unconstrained Binary Optimization (QUBO)</strong> problem. The high-level idea is to keep the original
        objective, and convert constraints into <em>quadratic penalty terms</em> added to the objective.
      </p>

      <h3>4.1 Objective reformulation</h3>
      <p>
        The original objective stays the same:
      </p>
      $$
      \min \sum_{j=1}^{m} y_j.
      $$
      <p>
        To enforce capacity in an unconstrained setting, we add a quadratic penalty that becomes large when a bin is overloaded.
        A common form is:
      </p>
      $$
      P_{\text{capacity}} = \alpha \sum_{j=1}^{m} \left(Cy_j - \sum_{i=1}^{n} w_i x_{ij}\right)^2,
      $$
      <p style="color: rgba(0,0,0,0.75);">
        where $\alpha$ is a large penalty weight. When $y_j=1$, the expression encourages the bin load to stay within capacity.
        When $y_j=0$, it discourages assigning any items to that bin.
      </p>

      <h3>4.2 Unconstraining the assignment constraint</h3>
      <p>
        The assignment constraint
        $$
        \sum_{j=1}^{m} x_{ij} = 1 \quad \forall i
        $$
        can be converted into a penalty term:
      </p>
      $$
      P_{\text{assign}} = \beta \sum_{i=1}^{n} \left(1 - \sum_{j=1}^{m} x_{ij}\right)^2,
      $$
      <p style="color: rgba(0,0,0,0.75);">
        where $\beta$ is a large penalty weight. This penalizes any solution where an item is assigned to zero bins or multiple bins.
      </p>

      <h3>4.3 Capacity constraint as a quadratic penalty</h3>
      <p>
        The original capacity constraint
        $$
        \sum_{i=1}^{n} w_i x_{ij} \le C y_j
        $$
        is represented through the quadratic penalty (as above):
      </p>
      $$
      P_{\text{capacity}} = \alpha \sum_{j=1}^{m} \left(Cy_j - \sum_{i=1}^{n} w_i x_{ij}\right)^2.
      $$

      <h3>4.4 Binary variable encoding</h3>
      <p>
        All variables used in the formulation are binary by construction:
      </p>
      $$
      x_{ij} \in \{0,1\}, \quad y_j \in \{0,1\}.
      $$

      <h3>4.5 Final QUBO objective</h3>
      <p>
        The final QUBO objective combines the original objective and both penalty terms:
      </p>
      $$
      Q(x,y) = \sum_{j=1}^{m} y_j
      + \alpha \sum_{j=1}^{m} \left(Cy_j - \sum_{i=1}^{n} w_i x_{ij}\right)^2
      + \beta \sum_{i=1}^{n} \left(1 - \sum_{j=1}^{m} x_{ij}\right)^2.
      $$
      <p style="color: rgba(0,0,0,0.75);">
        Choosing $\alpha$ and $\beta$ large enough is important: too small and constraints are violated; too large and the energy landscape
        may become poorly scaled for the optimizer.
      </p>
    </section>

    <section id="quantum-approach" class="project-section">
      <h2>5. Quantum approach</h2>
      <p>
        After converting the model into QUBO/Ising form, we can solve it using quantum (or quantum-inspired) optimization.
        In this repository, the core workflow follows a <strong>Variational Quantum Algorithm (VQA)</strong> pattern.
      </p>

      <h3 id="vqa-qaoa">5.2 Variational approach (QAOA): steps in the VQA approach</h3>
      <p>
        A VQA alternates between a quantum circuit (state preparation + measurement) and a classical optimizer (parameter update).
        The objective is to find a low-energy (ideally ground-state) solution of the problem Hamiltonian.
      </p>

      <ol>
        <li>
          <strong>Problem formulation (Ising Hamiltonian)</strong>
          <p>
            The optimization problem is mapped to an Ising Hamiltonian of the form:
          </p>
          $$
          H = \sum_i h_i Z_i + \sum_{i<j} J_{ij} Z_i Z_j,
          $$
          <p style="color: rgba(0,0,0,0.75);">
            where $h_i$ and $J_{ij}$ are problem-specific coefficients and $Z_i$ are Pauli-$Z$ operators acting on qubit $i$.
            The bitstring corresponding to the <em>minimum</em> energy approximates the optimal solution (minimum bins with feasible packing).
          </p>
        </li>

        <li>
          <strong>Parameter initialization</strong>
          <p>
            Choose a parameterized quantum circuit (ansatz). For QAOA, this is typically built from alternating layers of
            problem and mixer unitaries. Initialize parameters $\vec\theta$ (or $(\vec\gamma,\vec\beta)$ in QAOA).
          </p>
        </li>

        <li>
          <strong>Energy measurement</strong>
          <p>
            Execute the circuit to prepare a trial state $\lvert\psi(\vec\theta)\rangle$ and estimate the expected energy:
          </p>
          $$
          \langle H \rangle = \langle \psi(\vec\theta) \rvert H \lvert \psi(\vec\theta) \rangle.
          $$
        </li>

        <li>
          <strong>Classical optimization</strong>
          <p>
            Use a classical optimizer (gradient-free or gradient-based) to update parameters $\vec\theta$ to reduce $\langle H \rangle$.
          </p>
        </li>

        <li>
          <strong>Iterative refinement</strong>
          <p>
            Repeat measurement + classical update until convergence, yielding optimized parameters $\vec\theta^{\*}$.
          </p>
        </li>

        <li>
          <strong>Solution interpretation</strong>
          <p>
            Measure the final state $\lvert\psi(\vec\theta^{\*})\rangle$ in the computational basis to obtain bitstrings.
            Decode the best bitstring into the original decision variables ($x_{ij}$, $y_j$, and any slack variables), and interpret it
            as a bin assignment.
          </p>
        </li>
      </ol>
    </section>

    <section id="eigenstate-mapping" class="project-section">
      <h2>6. Mapping eigenstates to QUBO variables</h2>
      <p>
        Solvers like QAOA/VQE return bitstrings (eigenstates) such as <code>101001...</code>. To interpret a bitstring as a valid packing,
        we must know the exact ordering of binary variables used when building the QUBO.
      </p>

      <h3>6.1 Identify the ordering of variables</h3>
      <p>
        In the QUBO model, variables are flattened into a 1D list. An example ordering (as used in many bin-packing/QUBO encodings) is:
      </p>
      <div style="padding: 12px 14px; background: rgba(0,0,0,0.04); border: 1px solid rgba(0,0,0,0.08); border-radius: 10px;">
        <code>
          x0,0, x0,1, x1,0, x1,1, x2,0, x2,1, x3,0, x3,1, y0, y1,
          capacity bin 0 @int slack @0, capacity bin 0 @int slack @1,
          capacity bin 1 @int slack @0, capacity bin 1 @int slack @1,
          capacity bin 2 @int slack @0, capacity bin 2 @int slack @1
        </code>
      </div>

      <h3>6.2 Map an eigenstate to variables</h3>
      <p>
        Example eigenstate (bitstring) returned by a solver:
      </p>
      <div style="padding: 12px 14px; background: rgba(0,0,0,0.04); border: 1px solid rgba(0,0,0,0.08); border-radius: 10px;">
        <code>eigenstate = [1,0,0,1,1,0,0,1,1,1,0,0,0,0,0,0]</code>
      </div>

      <p style="margin-top: 12px;">
        Using the variable ordering above, we decode each bit into its corresponding variable:
      </p>

      <div style="overflow-x:auto; margin-top: 10px;">
        <table style="width:100%; border-collapse: collapse; min-width: 520px;">
          <thead>
            <tr>
              <th style="text-align:left; padding:10px; border-bottom: 2px solid rgba(0,0,0,0.12);">Binary variable</th>
              <th style="text-align:left; padding:10px; border-bottom: 2px solid rgba(0,0,0,0.12);">Eigenstate (0/1)</th>
            </tr>
          </thead>
          <tbody>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x0,0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">1</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x0,1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x1,0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x1,1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">1</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x2,0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">1</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x2,1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x3,0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">x3,1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">1</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">y0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">1</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">y1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">1</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">capacity bin 0 @int slack @0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">capacity bin 0 @int slack @1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">capacity bin 1 @int slack @0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">capacity bin 1 @int slack @1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">capacity bin 2 @int slack @0</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
            <tr><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">capacity bin 2 @int slack @1</td><td style="padding:10px; border-bottom: 1px solid rgba(0,0,0,0.08);">0</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <section id="notes" class="project-section">
      <h2>Notes</h2>
      <p>
        This page is part of my <a href="{{ '/projects/quantum-inspired-optimization.html' | relative_url }}">Quantum-Inspired Optimization</a>
        coursework repository.
      </p>
    </section>

  </article>

  <aside class="project-sidebar">
    <nav class="project-toc">
      <h4>Contents</h4>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#formulation">1. Mathematical formulation</a></li>
        <li><a href="#how-we-solve">2. How we solve it</a></li>
        <li><a href="#example">3. Small example instance</a></li>
        <li><a href="#ilp-to-qubo">4. ILP to QUBO Conversion</a></li>
        <li><a href="#quantum-approach">5. Quantum approach</a></li>
        <li><a href="#eigenstate-mapping">6. Mapping eigenstates</a></li>
        <li><a href="#notes">Notes</a></li>
      </ul>
    </nav>
  </aside>
</div>
